{"remainingRequest":"/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/src/views/Home.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/src/views/Home.vue","mtime":1587871341397},{"path":"/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBNYXAgZnJvbSAnQC9jb21wb25lbnRzL01hcC52dWUnCgppbXBvcnQgeyBOb3ZlbENvdmlkIH0gZnJvbSAnbm92ZWxjb3ZpZCcKaW1wb3J0IGNlbnN1cyBmcm9tICdjaXR5c2RrJwoKaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnCmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnQC91dGlsLmpzJwoKY29uc3QgREFURV9GT1JNQVQgPSAiWVlZWS1NTS1ERCI7CgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ0hvbWUnLAogIGNvbXBvbmVudHM6IHsKICAgIE1hcAogIH0sCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIGRheTogbW9tZW50KCksIC8vIERheSBiZWluZyBkaXNwbGF5ZWQgKHRvZGF5IGJ5IGRlZmF1bHQpCiAgICAgIHJlc29sdXRpb246ICdjb3VudGllcycsIC8vIFJlc29sdXRpb24gYmVpbmcgZGlzcGxheWVkCiAgICAgIHRyYWNrOiBuZXcgTm92ZWxDb3ZpZCgpLCAvLyBDb3ZpZCBkYXRhIHByb2N1cmVtZW50IG9iamVjdAogICAgICBjb3VudHlGSVBTOiBuZXcgU2V0KCksIC8vIEZJUFMgSURzIG9mIGFsbCBjb3VudGllcyByZXByZXNlbnRlZCBpbiB0aGUgZGF0YQogICAgICBnZW9EYXRhOiB7IC8vIEdlb2dyYXBoaWMgYW5kIGNlbnN1cyBkYXRhCiAgICAgICAgdXM6IHt9LAogICAgICAgIHN0YXRlczoge30sCiAgICAgICAgY291bnRpZXM6IHt9CiAgICAgIH0sCiAgICAgIGNvdmlkRGF0YTogeyAvLyBGdWxsIGhpc3Rvcnkgb2YgQ292aWQgZGF0YQogICAgICAgIHVzOiBbXSwKICAgICAgICBzdGF0ZXM6IFtdLAogICAgICAgIGNvdW50aWVzOiBbXQogICAgICB9LAogICAgICBjaGVja2xpc3Q6IHsgLy8gV2hpY2ggZGF0YSBlbGVtZW50cyBoYXZlIGJlZW4gbG9hZGVkIC8gY29tcHV0ZWQKICAgICAgICBnZW9EYXRhOiB7IC8vIEdlb2dyYXBoaWMgYW5kIGNlbnN1cyBkYXRhCiAgICAgICAgICBzdGF0ZXM6IDAsCiAgICAgICAgICBjb3VudGllczogMAogICAgICAgIH0sCiAgICAgICAgY292aWREYXRhOiB7IC8vIEZ1bGwgaGlzdG9yeSBvZiBDb3ZpZCBkYXRhCiAgICAgICAgICBjb3VudGllczogMAogICAgICAgIH0sCiAgICAgICAgY29tYm86IDAgLy8gQ29tcHV0ZWQgbWV0YWRhdGEgY29tYmluaW5nIGdlbyBhbmQgY292aWQgZGF0YQogICAgICB9CiAgICB9CiAgfSwKICBjcmVhdGVkKCl7CiAgICB0aGlzLmRhdGFzZXQgPSBSZWdpb25hbGl6ZWREYXRhLmxvYWRGcm9tT25saW5lKCk7CiAgICAvKgogICAgY29uc29sZS5sb2coIkxvYWRpbmcgR2VvZ3JhcGhpYyBhbmQgQ2Vuc3VzIERhdGEgLiAuIC4iKTsKICAgIHRoaXMubG9hZEdlb0RhdGEoKTsKICAgIGNvbnNvbGUubG9nKCJMb2FkaW5nIENvdmlkIERhdGEgLiAuIC4iKTsKICAgIHRoaXMubG9hZENvdmlkRGF0YSgpOyovCiAgfSwKCiAgbWV0aG9kczogewoKICAgIGNob3JvcGxldGhEYXRhKCl7CiAgICAgIHRoaXMuZGF0YXNldC5tYXAoIHJlZ2lvbiA9PiB7CiAgICAgICAgbGV0IGRhdGEgPSB7Zmlwczogc3RyaW5nKHJlZ2lvbi5kYXRhLmZpcHMpfTsKICAgICAgICBkYXRhW3RoaXMuY2hvcm9wbGV0aF92YWx1ZV0gPSByZWdpb24uZGF0YVtjaG9yb3BsZXRoX3ZhbHVlXVtkYXlfbnVtLXJlZ2lvbi5kYXlfemVyb107CiAgICAgICAgcmV0dXJuIGRhdGE7CiAgICAgIH0pOwogICAgfQoKICAgIC8vIERvZXMgd2hhdCBpdCBzYXlzIG9uIHRoZSB0aW4gKGxvYWRzIGdlb2dyYXBoaWMgYW5kIGNlbnN1cyBkYXRhKS4KICAgIGxvYWRHZW9EYXRhKCl7CiAgICAgIC8vIExvYWQgQ291bnR5IERhdGE6CiAgICAgIGNvbnNvbGUubG9nKCdcdCA+IENvdW50eSAuIC4gLicpOwogICAgICBjZW5zdXMoCiAgICAgICAgewogICAgICAgICAgdmludGFnZTogMjAxOCwgLy8gbW9zdCByZWNlbnQgY29tcGxldGUgZGF0YXNldAogICAgICAgICAgZ2VvSGllcmFyY2h5OiB7IGNvdW50eTogJyonIH0sCiAgICAgICAgICBnZW9SZXNvbHV0aW9uOiAiMjBtIiwKICAgICAgICAgIHNvdXJjZVBhdGg6IFsiYWNzIiwgImFjczUiXSwKICAgICAgICAgIHZhbHVlczogWyJCMDEwMDFfMDAxRSJdIC8vIHBvcHVsYXRpb24KICAgICAgICB9LAogICAgICAgIChlcnIscmVzKSA9PiB7CiAgICAgICAgICBpZihlcnIpewogICAgICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcigiRmFpbGVkIHRvIGxvYWQgY291bnR5IGRhdGEuIiwgZXJyKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuZ2VvRGF0YS5jb3VudGllcyA9IHJlczsKCiAgICAgICAgICAvLyBHZXQgaG91c2luZyBkYXRhOgogICAgICAgICAgY2Vuc3VzKAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgdmludGFnZTogMjAxOCwKICAgICAgICAgICAgICBnZW9IaWVyYXJjaHk6IHsgY291bnR5OiAnKicgfSwKICAgICAgICAgICAgICBzb3VyY2VQYXRoOiBbICJhY3MiLCAiYWNzNSIsICJwcm9maWxlIiBdLAogICAgICAgICAgICAgIHZhbHVlczogWyAiRFAwMl8wMDAxRSIgXQogICAgICAgICAgICB9LAogICAgICAgICAgICAoZXJyLHJlcykgPT4gewogICAgICAgICAgICAgIGlmKGVycil7CiAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcigiRmFpbGVkIHRvIGxvYWQgY291bnR5IGhvdXNlaG9sZCBkYXRhLiIsIGVycik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzOwogICAgICAgICAgICAgIC8vIE1lcmdlIGRhdGFzZXRzOgogICAgICAgICAgICAgIHJlcy5mb3JFYWNoKCBkID0+IHsKICAgICAgICAgICAgICAgIHRoaXMuZ2VvRGF0YS5jb3VudGllcy5mZWF0dXJlcy5maW5kKCB4ID0+IHgucHJvcGVydGllcy5HRU9JRCA9PT0gZC5zdGF0ZSArIGQuY291bnR5ICkucHJvcGVydGllcy5EUDAyXzAwMDFFID0gZC5EUDAyXzAwMDFFOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGNvbnNvbGUubG9nKCJDb3VudHktTGV2ZWwgR2VvIERhdGEgTG9hZGVkLiIpOwogICAgICAgICAgICB9CiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgKTsKICAgICAgLy8gTG9hZCBTdGF0ZSBEYXRhCiAgICAgIGNvbnNvbGUubG9nKCdcdCA+IFN0YXRlIC4gLiAuJyk7CiAgICAgIGNlbnN1cygKICAgICAgICB7CiAgICAgICAgICB2aW50YWdlOiAyMDE4LCAvLyBtb3N0IHJlY2VudCBjb21wbGV0ZSBkYXRhc2V0CiAgICAgICAgICBnZW9IaWVyYXJjaHk6IHsgc3RhdGU6ICcqJyB9LAogICAgICAgICAgZ2VvUmVzb2x1dGlvbjogIjIwbSIsCiAgICAgICAgICBzb3VyY2VQYXRoOiBbImFjcyIsICJhY3M1Il0sCiAgICAgICAgICB2YWx1ZXM6IFsiQjAxMDAxXzAwMUUiXSAvLyBwb3B1bGF0aW9uCiAgICAgICAgfSwKICAgICAgICAoZXJyLHJlcykgPT4gewogICAgICAgICAgaWYoZXJyKXsKICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoIkZhaWxlZCB0byBsb2FkIGNvdW50eSBkYXRhLiIsIGVycik7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLmdlb0RhdGEuc3RhdGVzID0gcmVzOwoKICAgICAgICAgIC8vIEdldCBob3VzaW5nIGRhdGE6CiAgICAgICAgICBjZW5zdXMoCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICB2aW50YWdlOiAyMDE4LAogICAgICAgICAgICAgIGdlb0hpZXJhcmNoeTogeyBzdGF0ZTogJyonIH0sCiAgICAgICAgICAgICAgc291cmNlUGF0aDogWyAiYWNzIiwgImFjczUiLCAicHJvZmlsZSIgXSwKICAgICAgICAgICAgICB2YWx1ZXM6IFsgIkRQMDJfMDAwMUUiIF0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgKGVycixyZXMpID0+IHsKICAgICAgICAgICAgICBpZihlcnIpewogICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoIkZhaWxlZCB0byBsb2FkIHN0YXRlIGhvdXNlaG9sZCBkYXRhLiIsIGVycik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIC8vIE1lcmdlIGRhdGFzZXRzOgogICAgICAgICAgICAgIHJlcy5mb3JFYWNoKCBkID0+IHsKICAgICAgICAgICAgICAgIHRoaXMuZ2VvRGF0YS5zdGF0ZXMuZmVhdHVyZXMuZmluZCggeCA9PiB4LnByb3BlcnRpZXMuR0VPSUQgPT09IGQuc3RhdGUgKS5wcm9wZXJ0aWVzLkRQMDJfMDAwMUUgPSBkLkRQMDJfMDAwMUU7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgY29uc29sZS5sb2coIkNvdW50eS1MZXZlbCBHZW8gRGF0YSBMb2FkZWQuIik7CiAgICAgICAgICAgIH0KICAgICAgICAgICk7CiAgICAgICAgfQogICAgICApOwogICAgfSwKCiAgICAvLyBEb2VzIHdoYXQgaXQgc2F5cyBvbiB0aGUgdGluICgrIGZvcm1hdHMgaXQgYW5kIGNvbXB1dGVzIG1ldGFwYXJhbXMpLgogICAgbG9hZENvdmlkRGF0YSgpewogICAgICBjb25zb2xlLmxvZygiXHQgPiBDb3VudHkgLiAuIC4iKTsKICAgICAgdGhpcy50cmFjay5ueXRDb3VudGllcygpLnRoZW4oCiAgICAgICAgZGF0YSA9PiB7CiAgICAgICAgICAvLyBFeHRyYWN0IERhdGUgUHJvcGVydGllczoKICAgICAgICAgIGRhdGEuZm9yRWFjaCggZCA9PiB7CiAgICAgICAgICAgIGQuZGF5ID0gbW9tZW50KGQuZGF0ZSwgREFURV9GT1JNQVQpOwogICAgICAgICAgfSk7CgogICAgICAgICAgLy8gQ29sbGVjdCB0aGUgSURzIG9mIGFsbCBjb3VudGllczoKICAgICAgICAgIGRhdGEuZm9yRWFjaCggZCA9PiB7CiAgICAgICAgICAgIHRoaXMuY291bnR5RklQUy5hZGQoZC5maXBzKTsKICAgICAgICAgIH0pOwoKICAgICAgICAgIC8vIEZpbGwgaW4gYW55IG1pc3NpbmcgZGF5czoKICAgICAgICAgIHRoaXMuY291bnR5RklQUy5mb3JFYWNoKCBmaXBzID0+IHsgLy8gRm9yIGV2ZXJ5IGNvdW50eToKICAgICAgICAgICAgLy8gQ29sbGVjdCB0aGUgaW5kaWNlcyBjb3JyZXNwb25kaW5nIHRvIGVhY2ggZm9yIHRoZSBjb3VudHk6CiAgICAgICAgICAgIGxldCBlbnRyaWVzID0gZGF0YS5maWx0ZXIoIGQgPT4gZC5maXBzID09PSBmaXBzICk7CiAgICAgICAgICAgIC8vIEdldCBkYXRlIHJhbmdlIG9mIGRhdGE6CiAgICAgICAgICAgIGxldCBkYXRlcyA9IGVudHJpZXMubWFwKCBkID0+IGQuZGF5ICk7CiAgICAgICAgICAgIGxldCBmaXJzdERheSA9IG1vbWVudC5taW4oZGF0ZXMpOwoKICAgICAgICAgICAgLy8gRm9yIGV2ZXJ5IGVudHJ5LCBjaGVjayB0byBzZWUgaWYgYW4gZW50cnkgZXhpc3RzIGZvciB0aGF0IGNvdW50eQogICAgICAgICAgICAvLyBmb3IgdGhlIG5leHQgZGF5IChpZiBub3QgdG9tb3Jyb3cpLCBpZiBpdCBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXQuCiAgICAgICAgICAgIGxldCB0b2RheSA9IG1vbWVudCgpOyAvLyBDb21wdXRlIHRoaXMgb25jZSBzbyBpdCByZW1haW5zIGZpeGVkIGR1cmluZyBpdGVyYXRpb24KICAgICAgICAgICAgbGV0IGRheSA9IGZpcnN0RGF5LmNsb25lKCk7CiAgICAgICAgICAgIGxldCBjdXJyRGF5RGF0YSA9IGVudHJpZXMuZmluZCggZCA9PiBkLmRheS5pc1NhbWUoZGF5KSApOwogICAgICAgICAgICBjdXJyRGF5RGF0YS5jb2xsZWN0aW9uX2RhdGUgPSBkYXkuZm9ybWF0KERBVEVfRk9STUFUKTsgLy8gQWRkIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBkYXRlIG9mIGNvbGxlY3Rpb24KICAgICAgICAgICAgd2hpbGUoIGRheS5pc0JlZm9yZSh0b2RheSwgJ2RheScpICl7CiAgICAgICAgICAgICAgbGV0IG5leHREYXkgPSBkYXkuY2xvbmUoKS5hZGQoMSwnZCcpOwogICAgICAgICAgICAgIGxldCBuZXh0RGF5RGF0YSA9IGVudHJpZXMuZmluZCggZCA9PiBkLmRheS5pc1NhbWUobmV4dERheSkgKTsKCiAgICAgICAgICAgICAgaWYobmV4dERheURhdGEgPT09IHVuZGVmaW5lZCl7CiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgY29weSBvZiBjdXJyZW50IGRhdGEgYnV0IHdpdGggdGhlIG5leHQgZGF5J3MgZGF0ZToKICAgICAgICAgICAgICAgIG5leHREYXlEYXRhID0geyAuLi5jdXJyRGF5RGF0YSB9OwogICAgICAgICAgICAgICAgbmV4dERheURhdGEuZGF5ID0gbmV4dERheTsKICAgICAgICAgICAgICAgIG5leHREYXlEYXRhLmRhdGUgPSBuZXh0RGF5LmZvcm1hdChEQVRFX0ZPUk1BVCk7CiAgICAgICAgICAgICAgICBuZXh0RGF5RGF0YS5jb2xsZWN0aW9uX2RhdGUgPSBjdXJyRGF5RGF0YS5jb2xsZWN0aW9uX2RhdGU7IC8vIFByZXNlcnZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBkYXRlIG9mIGNvbGxlY3Rpb24KCiAgICAgICAgICAgICAgICBkYXRhLnB1c2gobmV4dERheURhdGEpOyAvLyBBZGQgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIGRhdGFzZXQgZm9yIGxhdGVyIHVzZQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBuZXh0RGF5RGF0YS5jb2xsZWN0aW9uX2RhdGUgPSBuZXh0RGF5RGF0YS5kYXRlOyAvLyBBZGQgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIGRhdGUgb2YgY29sbGVjdGlvbiBmb3IgZGF0YSB1bmlmb3JtaXR5CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBjdXJyRGF5RGF0YSA9IG5leHREYXlEYXRhOwogICAgICAgICAgICAgIGRheSA9IG5leHREYXk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwoKICAgICAgICAgIHRoaXMuY292aWREYXRhLmNvdW50aWVzID0gZGF0YTsKICAgICAgICAgIGNvbnNvbGUubG9nKCJDb3ZpZCBEYXRhIExvYWRlZC4iKTsKICAgICAgICB9LAogICAgICAgIGVyciA9PiB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKCJDb3VsZG4ndCBsb2FkIGNvdW50eSBDb3ZpZCBkYXRhLiIsIGVycik7CiAgICAgICAgfQogICAgICApOwogICAgfQogIH0sCiAgY29tcHV0ZWQ6IHsKICAgIC8vIENvbXB1dGUgZGF0YSB0byBiZSBmZWQgdG8gdGhlIGNob3JvcGxldGggd2hpY2ggY29tYmluZXMgZ2VvZ3JhcGhpYywKICAgIC8vIGNlbnN1cywgYW5kIGNvdmlkIGRhdGEuCiAgICBjb21ib0RhdGEoKXsKICAgICAgbGV0IGNvbWJvID0gdGhpcy5jb3ZpZERhdGE7IC8vIG5vdGU6IHRoaXMgd2lsbCBhbHNvIG1vZGlmeSBjb3ZpZERhdGEuIFRoYXQncyBmaW5lLiBNYWlubHkgdGhpcyBwcm9wIGlzIHVzZWQgdG8gYWRkIHJlYWN0aXZpdHkuCgogICAgICAvLyBQcmUtY29tcHV0ZSBhZGRpdGlvbmFsIGRhdGE6CiAgICAgIC8vIHBlciBjYXBpdGEsIHBlciBob3VzZWhvbGQsIHBlciBhcmVhLCBwZXIgZGVuc2l0eQogICAgICBmb3IoY29uc3QgcmVzIGluIGNvbWJvKXsKICAgICAgICBpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5nZW9EYXRhW3Jlc10sICdmZWF0dXJlcycpKXsKICAgICAgICAgIC8vIE9ubHkgbW9kaWZ5IGRhdGEgZm9yIHRoZSBzZWxlY3RlZCBkYXk6CiAgICAgICAgICBsZXQgZGF0YSA9IGNvbWJvW3Jlc10uZmlsdGVyKCBkID0+IGQuZGF5LmlzU2FtZSh0aGlzLmRheSwgJ2RheScpICk7CiAgICAgICAgICAvLyBGb3IgZXZlcnkgcmVnaW9uOgogICAgICAgICAgdGhpcy5nZW9EYXRhW3Jlc10uZmVhdHVyZXMuZm9yRWFjaCggcmVnaW9uID0+IHsKICAgICAgICAgICAgLy8gR3JhYiByZWxldmFudCBtZXRhZGF0YToKICAgICAgICAgICAgbGV0IHBvcCA9IHJlZ2lvbi5wcm9wZXJ0aWVzLkIwMTAwMV8wMDFFOwogICAgICAgICAgICBsZXQgaG91c2VzID0gcmVnaW9uLnByb3BlcnRpZXMuRFAwMl8wMDAxRTsKICAgICAgICAgICAgbGV0IGFyZWEgPSByZWdpb24ucHJvcGVydGllcy5BTEFORCAvIDIuNTllNjsgLy8gbV4yIC0+IG1pXjIKICAgICAgICAgICAgbGV0IGRlbnNpdHkgPSBwb3AvYXJlYTsKICAgICAgICAgICAgLy8gR3JhYiBhbGwgY292aWQgZW50cmllcyBmb3IgdGhlIHJlZ2lvbjoKICAgICAgICAgICAgbGV0IGVudHJpZXMgPSBkYXRhLmZpbHRlciggZCA9PiBkLmZpcHMgPT09IHJlZ2lvbi5wcm9wZXJ0aWVzLkdFT0lEICk7CiAgICAgICAgICAgIC8vIEFkZCBtZXRhZGF0YSB0byBlYWNoIGVudHJ5OgogICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goIGUgPT4gewogICAgICAgICAgICAgIGlmKHJlcyA9PT0gJ2NvdW50aWVzJyAmJiAhZS5jb3VudHkuaW5jbHVkZXMoIkNvdW50eSIpKXsKICAgICAgICAgICAgICAgIGUuY291bnR5ID0gZS5jb3VudHkgKyAiIENvdW50eSI7IC8vIENsZWFybHkgc2VwYXJhdGUgbmFtZXMgb2YgY291bnRpZXMgZnJvbSBzdGF0ZXMKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZS5wb3AgPSBwb3AgLSBlLmRlYXRoczsKICAgICAgICAgICAgICBlLnBvcHVsYXRpb24gPSB1dGlsLmZvcm1hdFBvcHVsYXRpb24oZS5wb3ApOwogICAgICAgICAgICAgIGUuaG91c2Vob2xkcyA9IHV0aWwuZm9ybWF0UG9wdWxhdGlvbihob3VzZXMpOwogICAgICAgICAgICAgIGUuYXJlYSA9IGFyZWE7CiAgICAgICAgICAgICAgZS5kZW5zaXR5ID0gdXRpbC5mb3JtYXRQb3B1bGF0aW9uKGRlbnNpdHkpOwogICAgICAgICAgICAgIGUuY2FzZXNfcGVyX2NhcCA9IHV0aWwuZm9ybWF0UG9wdWxhdGlvbihlLmNhc2VzIC8gZS5wb3AgKiAxZTYpOwogICAgICAgICAgICAgIGUuY2FzZXNfcGVyX2hvdXNlID0gdXRpbC5mb3JtYXRQb3B1bGF0aW9uKGUuY2FzZXMgLyBob3VzZXMgKiAxZTYpOwogICAgICAgICAgICAgIGUuY2FzZXNfcGVyX2FyZWEgPSBlLmNhc2VzIC8gYXJlYTsKICAgICAgICAgICAgICBlLmNhc2VzX3Blcl9kZW5zID0gdXRpbC5mb3JtYXRQb3B1bGF0aW9uKGUuY2FzZXMgLyBkZW5zaXR5KTsKICAgICAgICAgICAgICBlLmRlYXRoc19wZXJfY2FwID0gdXRpbC5mb3JtYXRQb3B1bGF0aW9uKGUuZGVhdGhzIC8gZS5wb3AgKiAxZTYpOwogICAgICAgICAgICAgIGUuZGVhdGhzX3Blcl9ob3VzZSA9IHV0aWwuZm9ybWF0UG9wdWxhdGlvbihlLmRlYXRocyAvIGhvdXNlcyAqIDFlNik7CiAgICAgICAgICAgICAgZS5kZWF0aHNfcGVyX2FyZWEgPSBlLmRlYXRocyAvIGFyZWE7CiAgICAgICAgICAgICAgZS5kZWF0aHNfcGVyX2RlbnMgPSB1dGlsLmZvcm1hdFBvcHVsYXRpb24oZS5kZWF0aHMgLyBkZW5zaXR5KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnNvbGUubG9nKCJDb21ibyBEYXRhIFVwZGF0ZWQuIik7CiAgICAgIHJldHVybiBjb21ibzsKICAgIH0sCiAgICAvLyBSZXR1cm5zIHRoZSBHZW9KU09OIGJlaW5nIGRpc3BsYXllZCBvbiB0aGUgbWFwOgogICAgYWN0aXZlTWFwKCl7CiAgICAgIHJldHVybiB0aGlzLmdlb0RhdGFbdGhpcy5yZXNvbHV0aW9uXTsKICAgIH0sCiAgICAvLyBSZXR1cm5zIHRoZSBkYXRhIGJlaW5nIGRpc3BsYXllZDoKICAgIGFjdGl2ZURhdGEoKXsKICAgICAgLy8gRmluZCBtb3N0IHJlY2VudCBkYXRhIG9uIG9yIGJlZm9yZSBzZWxlY3RlZCBkYXk6CiAgICAgIHJldHVybiB0aGlzLmNvbWJvRGF0YVt0aGlzLnJlc29sdXRpb25dLmZpbHRlciggZCA9PiBkLmRheS5pc1NhbWUodGhpcy5kYXksICdkYXknKSApOwogICAgfQogIH0KfQo="},{"version":3,"sources":["Home.vue"],"names":[],"mappings":";;;;;;;;;;;;;;AAcA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Home.vue","sourceRoot":"src/views","sourcesContent":["<template>\n  <div class=\"home\">\n    <Map\n      :geoData=\"activeMap\"\n      :coreData=\"activeData\"\n      :value=\"{\n        key: 'deaths_per_cap',\n        metric: ' Confirmed Deaths per 1M People'\n      }\"\n    />\n  </div>\n</template>\n\n<script>\nimport Map from '@/components/Map.vue'\n\nimport { NovelCovid } from 'novelcovid'\nimport census from 'citysdk'\n\nimport moment from 'moment'\nimport * as util from '@/util.js'\n\nconst DATE_FORMAT = \"YYYY-MM-DD\";\n\nexport default {\n  name: 'Home',\n  components: {\n    Map\n  },\n  data() {\n    return {\n      day: moment(), // Day being displayed (today by default)\n      resolution: 'counties', // Resolution being displayed\n      track: new NovelCovid(), // Covid data procurement object\n      countyFIPS: new Set(), // FIPS IDs of all counties represented in the data\n      geoData: { // Geographic and census data\n        us: {},\n        states: {},\n        counties: {}\n      },\n      covidData: { // Full history of Covid data\n        us: [],\n        states: [],\n        counties: []\n      },\n      checklist: { // Which data elements have been loaded / computed\n        geoData: { // Geographic and census data\n          states: 0,\n          counties: 0\n        },\n        covidData: { // Full history of Covid data\n          counties: 0\n        },\n        combo: 0 // Computed metadata combining geo and covid data\n      }\n    }\n  },\n  created(){\n    this.dataset = RegionalizedData.loadFromOnline();\n    /*\n    console.log(\"Loading Geographic and Census Data . . .\");\n    this.loadGeoData();\n    console.log(\"Loading Covid Data . . .\");\n    this.loadCovidData();*/\n  },\n\n  methods: {\n\n    choroplethData(){\n      this.dataset.map( region => {\n        let data = {fips: string(region.data.fips)};\n        data[this.choropleth_value] = region.data[choropleth_value][day_num-region.day_zero];\n        return data;\n      });\n    }\n\n    // Does what it says on the tin (loads geographic and census data).\n    loadGeoData(){\n      // Load County Data:\n      console.log('\\t > County . . .');\n      census(\n        {\n          vintage: 2018, // most recent complete dataset\n          geoHierarchy: { county: '*' },\n          geoResolution: \"20m\",\n          sourcePath: [\"acs\", \"acs5\"],\n          values: [\"B01001_001E\"] // population\n        },\n        (err,res) => {\n          if(err){\n            return console.error(\"Failed to load county data.\", err);\n          }\n          this.geoData.counties = res;\n\n          // Get housing data:\n          census(\n            {\n              vintage: 2018,\n              geoHierarchy: { county: '*' },\n              sourcePath: [ \"acs\", \"acs5\", \"profile\" ],\n              values: [ \"DP02_0001E\" ]\n            },\n            (err,res) => {\n              if(err){\n                return console.error(\"Failed to load county household data.\", err);\n              }\n              const self = this;\n              // Merge datasets:\n              res.forEach( d => {\n                this.geoData.counties.features.find( x => x.properties.GEOID === d.state + d.county ).properties.DP02_0001E = d.DP02_0001E;\n              });\n              console.log(\"County-Level Geo Data Loaded.\");\n            }\n          );\n        }\n      );\n      // Load State Data\n      console.log('\\t > State . . .');\n      census(\n        {\n          vintage: 2018, // most recent complete dataset\n          geoHierarchy: { state: '*' },\n          geoResolution: \"20m\",\n          sourcePath: [\"acs\", \"acs5\"],\n          values: [\"B01001_001E\"] // population\n        },\n        (err,res) => {\n          if(err){\n            return console.error(\"Failed to load county data.\", err);\n          }\n          this.geoData.states = res;\n\n          // Get housing data:\n          census(\n            {\n              vintage: 2018,\n              geoHierarchy: { state: '*' },\n              sourcePath: [ \"acs\", \"acs5\", \"profile\" ],\n              values: [ \"DP02_0001E\" ]\n            },\n            (err,res) => {\n              if(err){\n                return console.error(\"Failed to load state household data.\", err);\n              }\n              // Merge datasets:\n              res.forEach( d => {\n                this.geoData.states.features.find( x => x.properties.GEOID === d.state ).properties.DP02_0001E = d.DP02_0001E;\n              });\n              console.log(\"County-Level Geo Data Loaded.\");\n            }\n          );\n        }\n      );\n    },\n\n    // Does what it says on the tin (+ formats it and computes metaparams).\n    loadCovidData(){\n      console.log(\"\\t > County . . .\");\n      this.track.nytCounties().then(\n        data => {\n          // Extract Date Properties:\n          data.forEach( d => {\n            d.day = moment(d.date, DATE_FORMAT);\n          });\n\n          // Collect the IDs of all counties:\n          data.forEach( d => {\n            this.countyFIPS.add(d.fips);\n          });\n\n          // Fill in any missing days:\n          this.countyFIPS.forEach( fips => { // For every county:\n            // Collect the indices corresponding to each for the county:\n            let entries = data.filter( d => d.fips === fips );\n            // Get date range of data:\n            let dates = entries.map( d => d.day );\n            let firstDay = moment.min(dates);\n\n            // For every entry, check to see if an entry exists for that county\n            // for the next day (if not tomorrow), if it doesn't exist, create it.\n            let today = moment(); // Compute this once so it remains fixed during iteration\n            let day = firstDay.clone();\n            let currDayData = entries.find( d => d.day.isSame(day) );\n            currDayData.collection_date = day.format(DATE_FORMAT); // Add reference to original date of collection\n            while( day.isBefore(today, 'day') ){\n              let nextDay = day.clone().add(1,'d');\n              let nextDayData = entries.find( d => d.day.isSame(nextDay) );\n\n              if(nextDayData === undefined){\n                // Create copy of current data but with the next day's date:\n                nextDayData = { ...currDayData };\n                nextDayData.day = nextDay;\n                nextDayData.date = nextDay.format(DATE_FORMAT);\n                nextDayData.collection_date = currDayData.collection_date; // Preserve reference to original date of collection\n\n                data.push(nextDayData); // Add reference to original dataset for later use\n              } else {\n                nextDayData.collection_date = nextDayData.date; // Add reference to original date of collection for data uniformity\n              }\n\n              currDayData = nextDayData;\n              day = nextDay;\n            }\n          });\n\n          this.covidData.counties = data;\n          console.log(\"Covid Data Loaded.\");\n        },\n        err => {\n          console.error(\"Couldn't load county Covid data.\", err);\n        }\n      );\n    }\n  },\n  computed: {\n    // Compute data to be fed to the choropleth which combines geographic,\n    // census, and covid data.\n    comboData(){\n      let combo = this.covidData; // note: this will also modify covidData. That's fine. Mainly this prop is used to add reactivity.\n\n      // Pre-compute additional data:\n      // per capita, per household, per area, per density\n      for(const res in combo){\n        if(Object.prototype.hasOwnProperty.call(this.geoData[res], 'features')){\n          // Only modify data for the selected day:\n          let data = combo[res].filter( d => d.day.isSame(this.day, 'day') );\n          // For every region:\n          this.geoData[res].features.forEach( region => {\n            // Grab relevant metadata:\n            let pop = region.properties.B01001_001E;\n            let houses = region.properties.DP02_0001E;\n            let area = region.properties.ALAND / 2.59e6; // m^2 -> mi^2\n            let density = pop/area;\n            // Grab all covid entries for the region:\n            let entries = data.filter( d => d.fips === region.properties.GEOID );\n            // Add metadata to each entry:\n            entries.forEach( e => {\n              if(res === 'counties' && !e.county.includes(\"County\")){\n                e.county = e.county + \" County\"; // Clearly separate names of counties from states\n              }\n              e.pop = pop - e.deaths;\n              e.population = util.formatPopulation(e.pop);\n              e.households = util.formatPopulation(houses);\n              e.area = area;\n              e.density = util.formatPopulation(density);\n              e.cases_per_cap = util.formatPopulation(e.cases / e.pop * 1e6);\n              e.cases_per_house = util.formatPopulation(e.cases / houses * 1e6);\n              e.cases_per_area = e.cases / area;\n              e.cases_per_dens = util.formatPopulation(e.cases / density);\n              e.deaths_per_cap = util.formatPopulation(e.deaths / e.pop * 1e6);\n              e.deaths_per_house = util.formatPopulation(e.deaths / houses * 1e6);\n              e.deaths_per_area = e.deaths / area;\n              e.deaths_per_dens = util.formatPopulation(e.deaths / density);\n            });\n          });\n        }\n      }\n\n      console.log(\"Combo Data Updated.\");\n      return combo;\n    },\n    // Returns the GeoJSON being displayed on the map:\n    activeMap(){\n      return this.geoData[this.resolution];\n    },\n    // Returns the data being displayed:\n    activeData(){\n      // Find most recent data on or before selected day:\n      return this.comboData[this.resolution].filter( d => d.day.isSame(this.day, 'day') );\n    }\n  }\n}\n</script>\n\n<style scoped lang=\"scss\">\n\n</style>\n"]}]}