{"remainingRequest":"/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/src/views/Home.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/src/views/Home.vue","mtime":1587453510779},{"path":"/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/connorcolombo/Documents/PKBACK/GitHub/CovidDashboard/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBNYXAgZnJvbSAnQC9jb21wb25lbnRzL01hcC52dWUnCgppbXBvcnQgeyBOb3ZlbENvdmlkIH0gZnJvbSAnbm92ZWxjb3ZpZCcKaW1wb3J0IGNlbnN1cyBmcm9tICdjaXR5c2RrJwoKaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnCmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnQC91dGlsLmpzJwoKY29uc3QgREFURV9GT1JNQVQgPSAiWVlZWS1NTS1ERCI7CgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ0hvbWUnLAogIGNvbXBvbmVudHM6IHsKICAgIE1hcAogIH0sCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIGRheTogbW9tZW50KCksIC8vIERheSBiZWluZyBkaXNwbGF5ZWQgKHRvZGF5IGJ5IGRlZmF1bHQpCiAgICAgIHJlc29sdXRpb246ICdjb3VudGllcycsIC8vIFJlc29sdXRpb24gYmVpbmcgZGlzcGxheWVkCiAgICAgIHRyYWNrOiBuZXcgTm92ZWxDb3ZpZCgpLCAvLyBDb3ZpZCBkYXRhIHByb2N1cmVtZW50IG9iamVjdAogICAgICBjb3VudHlGSVBTOiBuZXcgU2V0KCksIC8vIEZJUFMgSURzIG9mIGFsbCBjb3VudGllcyByZXByZXNlbnRlZCBpbiB0aGUgZGF0YQogICAgICBnZW9EYXRhOiB7IC8vIEdlb2dyYXBoaWMgYW5kIGNlbnN1cyBkYXRhCiAgICAgICAgdXM6IHt9LAogICAgICAgIHN0YXRlczoge30sCiAgICAgICAgY291bnRpZXM6IHt9CiAgICAgIH0sCiAgICAgIGNvdmlkRGF0YTogeyAvLyBGdWxsIGhpc3Rvcnkgb2YgQ292aWQgZGF0YQogICAgICAgIHVzOiBbXSwKICAgICAgICBzdGF0ZXM6IFtdLAogICAgICAgIGNvdW50aWVzOiBbXQogICAgICB9LAogICAgICBjaGVja2xpc3Q6IHsgLy8gV2hpY2ggZGF0YSBlbGVtZW50cyBoYXZlIGJlZW4gbG9hZGVkIC8gY29tcHV0ZWQKICAgICAgICBnZW9EYXRhOiB7IC8vIEdlb2dyYXBoaWMgYW5kIGNlbnN1cyBkYXRhCiAgICAgICAgICBzdGF0ZXM6IDAsCiAgICAgICAgICBjb3VudGllczogMAogICAgICAgIH0sCiAgICAgICAgY292aWREYXRhOiB7IC8vIEZ1bGwgaGlzdG9yeSBvZiBDb3ZpZCBkYXRhCiAgICAgICAgICBjb3VudGllczogMAogICAgICAgIH0sCiAgICAgICAgY29tYm86IDAgLy8gQ29tcHV0ZWQgbWV0YWRhdGEgY29tYmluaW5nIGdlbyBhbmQgY292aWQgZGF0YQogICAgICB9CiAgICB9CiAgfSwKICBjcmVhdGVkKCl7CiAgICBjb25zb2xlLmxvZygiTG9hZGluZyBHZW9ncmFwaGljIGFuZCBDZW5zdXMgRGF0YSAuIC4gLiIpOwogICAgdGhpcy5sb2FkR2VvRGF0YSgpOwogICAgY29uc29sZS5sb2coIkxvYWRpbmcgQ292aWQgRGF0YSAuIC4gLiIpOwogICAgdGhpcy5sb2FkQ292aWREYXRhKCk7CiAgfSwKCiAgbWV0aG9kczogewogICAgLy8gRG9lcyB3aGF0IGl0IHNheXMgb24gdGhlIHRpbiAobG9hZHMgZ2VvZ3JhcGhpYyBhbmQgY2Vuc3VzIGRhdGEpLgogICAgbG9hZEdlb0RhdGEoKXsKICAgICAgLy8gTG9hZCBDb3VudHkgRGF0YToKICAgICAgY29uc29sZS5sb2coJ1x0ID4gQ291bnR5IC4gLiAuJyk7CiAgICAgIGNlbnN1cygKICAgICAgICB7CiAgICAgICAgICB2aW50YWdlOiAyMDE4LCAvLyBtb3N0IHJlY2VudCBjb21wbGV0ZSBkYXRhc2V0CiAgICAgICAgICBnZW9IaWVyYXJjaHk6IHsgY291bnR5OiAnKicgfSwKICAgICAgICAgIGdlb1Jlc29sdXRpb246ICIyMG0iLAogICAgICAgICAgc291cmNlUGF0aDogWyJhY3MiLCAiYWNzNSJdLAogICAgICAgICAgdmFsdWVzOiBbIkIwMTAwMV8wMDFFIl0gLy8gcG9wdWxhdGlvbgogICAgICAgIH0sCiAgICAgICAgKGVycixyZXMpID0+IHsKICAgICAgICAgIGlmKGVycil7CiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCJGYWlsZWQgdG8gbG9hZCBjb3VudHkgZGF0YS4iLCBlcnIpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5nZW9EYXRhLmNvdW50aWVzID0gcmVzOwoKICAgICAgICAgIC8vIEdldCBob3VzaW5nIGRhdGE6CiAgICAgICAgICBjZW5zdXMoCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICB2aW50YWdlOiAyMDE4LAogICAgICAgICAgICAgIGdlb0hpZXJhcmNoeTogeyBjb3VudHk6ICcqJyB9LAogICAgICAgICAgICAgIHNvdXJjZVBhdGg6IFsgImFjcyIsICJhY3M1IiwgInByb2ZpbGUiIF0sCiAgICAgICAgICAgICAgdmFsdWVzOiBbICJEUDAyXzAwMDFFIiBdCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIChlcnIscmVzKSA9PiB7CiAgICAgICAgICAgICAgaWYoZXJyKXsKICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCJGYWlsZWQgdG8gbG9hZCBjb3VudHkgaG91c2Vob2xkIGRhdGEuIiwgZXJyKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7CiAgICAgICAgICAgICAgLy8gTWVyZ2UgZGF0YXNldHM6CiAgICAgICAgICAgICAgcmVzLmZvckVhY2goIGQgPT4gewogICAgICAgICAgICAgICAgdGhpcy5nZW9EYXRhLmNvdW50aWVzLmZlYXR1cmVzLmZpbmQoIHggPT4geC5wcm9wZXJ0aWVzLkdFT0lEID09PSBkLnN0YXRlICsgZC5jb3VudHkgKS5wcm9wZXJ0aWVzLkRQMDJfMDAwMUUgPSBkLkRQMDJfMDAwMUU7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgY29uc29sZS5sb2coIkNvdW50eS1MZXZlbCBHZW8gRGF0YSBMb2FkZWQuIik7CiAgICAgICAgICAgIH0KICAgICAgICAgICk7CiAgICAgICAgfQogICAgICApOwogICAgICAvLyBMb2FkIFN0YXRlIERhdGEKICAgICAgY29uc29sZS5sb2coJ1x0ID4gU3RhdGUgLiAuIC4nKTsKICAgICAgY2Vuc3VzKAogICAgICAgIHsKICAgICAgICAgIHZpbnRhZ2U6IDIwMTgsIC8vIG1vc3QgcmVjZW50IGNvbXBsZXRlIGRhdGFzZXQKICAgICAgICAgIGdlb0hpZXJhcmNoeTogeyBzdGF0ZTogJyonIH0sCiAgICAgICAgICBnZW9SZXNvbHV0aW9uOiAiMjBtIiwKICAgICAgICAgIHNvdXJjZVBhdGg6IFsiYWNzIiwgImFjczUiXSwKICAgICAgICAgIHZhbHVlczogWyJCMDEwMDFfMDAxRSJdIC8vIHBvcHVsYXRpb24KICAgICAgICB9LAogICAgICAgIChlcnIscmVzKSA9PiB7CiAgICAgICAgICBpZihlcnIpewogICAgICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcigiRmFpbGVkIHRvIGxvYWQgY291bnR5IGRhdGEuIiwgZXJyKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuZ2VvRGF0YS5zdGF0ZXMgPSByZXM7CgogICAgICAgICAgLy8gR2V0IGhvdXNpbmcgZGF0YToKICAgICAgICAgIGNlbnN1cygKICAgICAgICAgICAgewogICAgICAgICAgICAgIHZpbnRhZ2U6IDIwMTgsCiAgICAgICAgICAgICAgZ2VvSGllcmFyY2h5OiB7IHN0YXRlOiAnKicgfSwKICAgICAgICAgICAgICBzb3VyY2VQYXRoOiBbICJhY3MiLCAiYWNzNSIsICJwcm9maWxlIiBdLAogICAgICAgICAgICAgIHZhbHVlczogWyAiRFAwMl8wMDAxRSIgXQogICAgICAgICAgICB9LAogICAgICAgICAgICAoZXJyLHJlcykgPT4gewogICAgICAgICAgICAgIGlmKGVycil7CiAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcigiRmFpbGVkIHRvIGxvYWQgc3RhdGUgaG91c2Vob2xkIGRhdGEuIiwgZXJyKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgLy8gTWVyZ2UgZGF0YXNldHM6CiAgICAgICAgICAgICAgcmVzLmZvckVhY2goIGQgPT4gewogICAgICAgICAgICAgICAgdGhpcy5nZW9EYXRhLnN0YXRlcy5mZWF0dXJlcy5maW5kKCB4ID0+IHgucHJvcGVydGllcy5HRU9JRCA9PT0gZC5zdGF0ZSApLnByb3BlcnRpZXMuRFAwMl8wMDAxRSA9IGQuRFAwMl8wMDAxRTsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICBjb25zb2xlLmxvZygiQ291bnR5LUxldmVsIEdlbyBEYXRhIExvYWRlZC4iKTsKICAgICAgICAgICAgfQogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICk7CiAgICB9LAoKICAgIC8vIERvZXMgd2hhdCBpdCBzYXlzIG9uIHRoZSB0aW4gKCsgZm9ybWF0cyBpdCBhbmQgY29tcHV0ZXMgbWV0YXBhcmFtcykuCiAgICBsb2FkQ292aWREYXRhKCl7CiAgICAgIGNvbnNvbGUubG9nKCJcdCA+IENvdW50eSAuIC4gLiIpOwogICAgICB0aGlzLnRyYWNrLm55dENvdW50aWVzKCkudGhlbigKICAgICAgICBkYXRhID0+IHsKICAgICAgICAgIC8vIEV4dHJhY3QgRGF0ZSBQcm9wZXJ0aWVzOgogICAgICAgICAgZGF0YS5mb3JFYWNoKCBkID0+IHsKICAgICAgICAgICAgZC5kYXkgPSBtb21lbnQoZC5kYXRlLCBEQVRFX0ZPUk1BVCk7CiAgICAgICAgICB9KTsKCiAgICAgICAgICAvLyBDb2xsZWN0IHRoZSBJRHMgb2YgYWxsIGNvdW50aWVzOgogICAgICAgICAgZGF0YS5mb3JFYWNoKCBkID0+IHsKICAgICAgICAgICAgdGhpcy5jb3VudHlGSVBTLmFkZChkLmZpcHMpOwogICAgICAgICAgfSk7CgogICAgICAgICAgLy8gRmlsbCBpbiBhbnkgbWlzc2luZyBkYXlzOgogICAgICAgICAgdGhpcy5jb3VudHlGSVBTLmZvckVhY2goIGZpcHMgPT4geyAvLyBGb3IgZXZlcnkgY291bnR5OgogICAgICAgICAgICAvLyBDb2xsZWN0IHRoZSBpbmRpY2VzIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBmb3IgdGhlIGNvdW50eToKICAgICAgICAgICAgbGV0IGVudHJpZXMgPSBkYXRhLmZpbHRlciggZCA9PiBkLmZpcHMgPT09IGZpcHMgKTsKICAgICAgICAgICAgLy8gR2V0IGRhdGUgcmFuZ2Ugb2YgZGF0YToKICAgICAgICAgICAgbGV0IGRhdGVzID0gZW50cmllcy5tYXAoIGQgPT4gZC5kYXkgKTsKICAgICAgICAgICAgbGV0IGZpcnN0RGF5ID0gbW9tZW50Lm1pbihkYXRlcyk7CgogICAgICAgICAgICAvLyBGb3IgZXZlcnkgZW50cnksIGNoZWNrIHRvIHNlZSBpZiBhbiBlbnRyeSBleGlzdHMgZm9yIHRoYXQgY291bnR5CiAgICAgICAgICAgIC8vIGZvciB0aGUgbmV4dCBkYXkgKGlmIG5vdCB0b21vcnJvdyksIGlmIGl0IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdC4KICAgICAgICAgICAgbGV0IHRvZGF5ID0gbW9tZW50KCk7IC8vIENvbXB1dGUgdGhpcyBvbmNlIHNvIGl0IHJlbWFpbnMgZml4ZWQgZHVyaW5nIGl0ZXJhdGlvbgogICAgICAgICAgICBsZXQgZGF5ID0gZmlyc3REYXkuY2xvbmUoKTsKICAgICAgICAgICAgbGV0IGN1cnJEYXlEYXRhID0gZW50cmllcy5maW5kKCBkID0+IGQuZGF5LmlzU2FtZShkYXkpICk7CiAgICAgICAgICAgIGN1cnJEYXlEYXRhLmNvbGxlY3Rpb25fZGF0ZSA9IGRheS5mb3JtYXQoREFURV9GT1JNQVQpOyAvLyBBZGQgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIGRhdGUgb2YgY29sbGVjdGlvbgogICAgICAgICAgICB3aGlsZSggZGF5LmlzQmVmb3JlKHRvZGF5LCAnZGF5JykgKXsKICAgICAgICAgICAgICBsZXQgbmV4dERheSA9IGRheS5jbG9uZSgpLmFkZCgxLCdkJyk7CiAgICAgICAgICAgICAgbGV0IG5leHREYXlEYXRhID0gZW50cmllcy5maW5kKCBkID0+IGQuZGF5LmlzU2FtZShuZXh0RGF5KSApOwoKICAgICAgICAgICAgICBpZihuZXh0RGF5RGF0YSA9PT0gdW5kZWZpbmVkKXsKICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBjb3B5IG9mIGN1cnJlbnQgZGF0YSBidXQgd2l0aCB0aGUgbmV4dCBkYXkncyBkYXRlOgogICAgICAgICAgICAgICAgbmV4dERheURhdGEgPSB7IC4uLmN1cnJEYXlEYXRhIH07CiAgICAgICAgICAgICAgICBuZXh0RGF5RGF0YS5kYXkgPSBuZXh0RGF5OwogICAgICAgICAgICAgICAgbmV4dERheURhdGEuZGF0ZSA9IG5leHREYXkuZm9ybWF0KERBVEVfRk9STUFUKTsKICAgICAgICAgICAgICAgIG5leHREYXlEYXRhLmNvbGxlY3Rpb25fZGF0ZSA9IGN1cnJEYXlEYXRhLmNvbGxlY3Rpb25fZGF0ZTsgLy8gUHJlc2VydmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIGRhdGUgb2YgY29sbGVjdGlvbgoKICAgICAgICAgICAgICAgIGRhdGEucHVzaChuZXh0RGF5RGF0YSk7IC8vIEFkZCByZWZlcmVuY2UgdG8gb3JpZ2luYWwgZGF0YXNldCBmb3IgbGF0ZXIgdXNlCiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIG5leHREYXlEYXRhLmNvbGxlY3Rpb25fZGF0ZSA9IG5leHREYXlEYXRhLmRhdGU7IC8vIEFkZCByZWZlcmVuY2UgdG8gb3JpZ2luYWwgZGF0ZSBvZiBjb2xsZWN0aW9uIGZvciBkYXRhIHVuaWZvcm1pdHkKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGN1cnJEYXlEYXRhID0gbmV4dERheURhdGE7CiAgICAgICAgICAgICAgZGF5ID0gbmV4dERheTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CgogICAgICAgICAgdGhpcy5jb3ZpZERhdGEuY291bnRpZXMgPSBkYXRhOwogICAgICAgICAgY29uc29sZS5sb2coIkNvdmlkIERhdGEgTG9hZGVkLiIpOwogICAgICAgIH0sCiAgICAgICAgZXJyID0+IHsKICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIkNvdWxkbid0IGxvYWQgY291bnR5IENvdmlkIGRhdGEuIiwgZXJyKTsKICAgICAgICB9CiAgICAgICk7CiAgICB9CiAgfSwKICBjb21wdXRlZDogewogICAgLy8gQ29tcHV0ZSBkYXRhIHRvIGJlIGZlZCB0byB0aGUgY2hvcm9wbGV0aCB3aGljaCBjb21iaW5lcyBnZW9ncmFwaGljLAogICAgLy8gY2Vuc3VzLCBhbmQgY292aWQgZGF0YS4KICAgIGNvbWJvRGF0YSgpewogICAgICBsZXQgY29tYm8gPSB0aGlzLmNvdmlkRGF0YTsgLy8gbm90ZTogdGhpcyB3aWxsIGFsc28gbW9kaWZ5IGNvdmlkRGF0YS4gVGhhdCdzIGZpbmUuIE1haW5seSB0aGlzIHByb3AgaXMgdXNlZCB0byBhZGQgcmVhY3Rpdml0eS4KCiAgICAgIC8vIFByZS1jb21wdXRlIGFkZGl0aW9uYWwgZGF0YToKICAgICAgLy8gcGVyIGNhcGl0YSwgcGVyIGhvdXNlaG9sZCwgcGVyIGFyZWEsIHBlciBkZW5zaXR5CiAgICAgIGZvcihjb25zdCByZXMgaW4gY29tYm8pewogICAgICAgIGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmdlb0RhdGFbcmVzXSwgJ2ZlYXR1cmVzJykpewogICAgICAgICAgLy8gT25seSBtb2RpZnkgZGF0YSBmb3IgdGhlIHNlbGVjdGVkIGRheToKICAgICAgICAgIGxldCBkYXRhID0gY29tYm9bcmVzXS5maWx0ZXIoIGQgPT4gZC5kYXkuaXNTYW1lKHRoaXMuZGF5LCAnZGF5JykgKTsKICAgICAgICAgIC8vIEZvciBldmVyeSByZWdpb246CiAgICAgICAgICB0aGlzLmdlb0RhdGFbcmVzXS5mZWF0dXJlcy5mb3JFYWNoKCByZWdpb24gPT4gewogICAgICAgICAgICAvLyBHcmFiIHJlbGV2YW50IG1ldGFkYXRhOgogICAgICAgICAgICBsZXQgcG9wID0gcmVnaW9uLnByb3BlcnRpZXMuQjAxMDAxXzAwMUU7CiAgICAgICAgICAgIGxldCBob3VzZXMgPSByZWdpb24ucHJvcGVydGllcy5EUDAyXzAwMDFFOwogICAgICAgICAgICBsZXQgYXJlYSA9IHJlZ2lvbi5wcm9wZXJ0aWVzLkFMQU5EIC8gMi41OWU2OyAvLyBtXjIgLT4gbWleMgogICAgICAgICAgICBsZXQgZGVuc2l0eSA9IHBvcC9hcmVhOwogICAgICAgICAgICAvLyBHcmFiIGFsbCBjb3ZpZCBlbnRyaWVzIGZvciB0aGUgcmVnaW9uOgogICAgICAgICAgICBsZXQgZW50cmllcyA9IGRhdGEuZmlsdGVyKCBkID0+IGQuZmlwcyA9PT0gcmVnaW9uLnByb3BlcnRpZXMuR0VPSUQgKTsKICAgICAgICAgICAgLy8gQWRkIG1ldGFkYXRhIHRvIGVhY2ggZW50cnk6CiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCggZSA9PiB7CiAgICAgICAgICAgICAgaWYocmVzID09PSAnY291bnRpZXMnICYmICFlLmNvdW50eS5pbmNsdWRlcygiQ291bnR5IikpewogICAgICAgICAgICAgICAgZS5jb3VudHkgPSBlLmNvdW50eSArICIgQ291bnR5IjsgLy8gQ2xlYXJseSBzZXBhcmF0ZSBuYW1lcyBvZiBjb3VudGllcyBmcm9tIHN0YXRlcwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlLnBvcCA9IHBvcCAtIGUuZGVhdGhzOwogICAgICAgICAgICAgIGUucG9wdWxhdGlvbiA9IHV0aWwuZm9ybWF0UG9wdWxhdGlvbihlLnBvcCk7CiAgICAgICAgICAgICAgZS5ob3VzZWhvbGRzID0gdXRpbC5mb3JtYXRQb3B1bGF0aW9uKGhvdXNlcyk7CiAgICAgICAgICAgICAgZS5hcmVhID0gYXJlYTsKICAgICAgICAgICAgICBlLmRlbnNpdHkgPSB1dGlsLmZvcm1hdFBvcHVsYXRpb24oZGVuc2l0eSk7CiAgICAgICAgICAgICAgZS5jYXNlc19wZXJfY2FwID0gdXRpbC5mb3JtYXRQb3B1bGF0aW9uKGUuY2FzZXMgLyBlLnBvcCAqIDFlNik7CiAgICAgICAgICAgICAgZS5jYXNlc19wZXJfaG91c2UgPSB1dGlsLmZvcm1hdFBvcHVsYXRpb24oZS5jYXNlcyAvIGhvdXNlcyAqIDFlNik7CiAgICAgICAgICAgICAgZS5jYXNlc19wZXJfYXJlYSA9IGUuY2FzZXMgLyBhcmVhOwogICAgICAgICAgICAgIGUuY2FzZXNfcGVyX2RlbnMgPSB1dGlsLmZvcm1hdFBvcHVsYXRpb24oZS5jYXNlcyAvIGRlbnNpdHkpOwogICAgICAgICAgICAgIGUuZGVhdGhzX3Blcl9jYXAgPSB1dGlsLmZvcm1hdFBvcHVsYXRpb24oZS5kZWF0aHMgLyBlLnBvcCAqIDFlNik7CiAgICAgICAgICAgICAgZS5kZWF0aHNfcGVyX2hvdXNlID0gdXRpbC5mb3JtYXRQb3B1bGF0aW9uKGUuZGVhdGhzIC8gaG91c2VzICogMWU2KTsKICAgICAgICAgICAgICBlLmRlYXRoc19wZXJfYXJlYSA9IGUuZGVhdGhzIC8gYXJlYTsKICAgICAgICAgICAgICBlLmRlYXRoc19wZXJfZGVucyA9IHV0aWwuZm9ybWF0UG9wdWxhdGlvbihlLmRlYXRocyAvIGRlbnNpdHkpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfQoKICAgICAgY29uc29sZS5sb2coIkNvbWJvIERhdGEgVXBkYXRlZC4iKTsKICAgICAgcmV0dXJuIGNvbWJvOwogICAgfSwKICAgIC8vIFJldHVybnMgdGhlIEdlb0pTT04gYmVpbmcgZGlzcGxheWVkIG9uIHRoZSBtYXA6CiAgICBhY3RpdmVNYXAoKXsKICAgICAgcmV0dXJuIHRoaXMuZ2VvRGF0YVt0aGlzLnJlc29sdXRpb25dOwogICAgfSwKICAgIC8vIFJldHVybnMgdGhlIGRhdGEgYmVpbmcgZGlzcGxheWVkOgogICAgYWN0aXZlRGF0YSgpewogICAgICAvLyBGaW5kIG1vc3QgcmVjZW50IGRhdGEgb24gb3IgYmVmb3JlIHNlbGVjdGVkIGRheToKICAgICAgcmV0dXJuIHRoaXMuY29tYm9EYXRhW3RoaXMucmVzb2x1dGlvbl0uZmlsdGVyKCBkID0+IGQuZGF5LmlzU2FtZSh0aGlzLmRheSwgJ2RheScpICk7CiAgICB9CiAgfQp9Cg=="},{"version":3,"sources":["Home.vue"],"names":[],"mappings":";;;;;;;;;;;;;;AAcA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Home.vue","sourceRoot":"src/views","sourcesContent":["<template>\n  <div class=\"home\">\n    <Map\n      :geoData=\"activeMap\"\n      :coreData=\"activeData\"\n      :value=\"{\n        key: 'cases',\n        metric: ' Confirmed Cases'\n      }\"\n    />\n  </div>\n</template>\n\n<script>\nimport Map from '@/components/Map.vue'\n\nimport { NovelCovid } from 'novelcovid'\nimport census from 'citysdk'\n\nimport moment from 'moment'\nimport * as util from '@/util.js'\n\nconst DATE_FORMAT = \"YYYY-MM-DD\";\n\nexport default {\n  name: 'Home',\n  components: {\n    Map\n  },\n  data() {\n    return {\n      day: moment(), // Day being displayed (today by default)\n      resolution: 'counties', // Resolution being displayed\n      track: new NovelCovid(), // Covid data procurement object\n      countyFIPS: new Set(), // FIPS IDs of all counties represented in the data\n      geoData: { // Geographic and census data\n        us: {},\n        states: {},\n        counties: {}\n      },\n      covidData: { // Full history of Covid data\n        us: [],\n        states: [],\n        counties: []\n      },\n      checklist: { // Which data elements have been loaded / computed\n        geoData: { // Geographic and census data\n          states: 0,\n          counties: 0\n        },\n        covidData: { // Full history of Covid data\n          counties: 0\n        },\n        combo: 0 // Computed metadata combining geo and covid data\n      }\n    }\n  },\n  created(){\n    console.log(\"Loading Geographic and Census Data . . .\");\n    this.loadGeoData();\n    console.log(\"Loading Covid Data . . .\");\n    this.loadCovidData();\n  },\n\n  methods: {\n    // Does what it says on the tin (loads geographic and census data).\n    loadGeoData(){\n      // Load County Data:\n      console.log('\\t > County . . .');\n      census(\n        {\n          vintage: 2018, // most recent complete dataset\n          geoHierarchy: { county: '*' },\n          geoResolution: \"20m\",\n          sourcePath: [\"acs\", \"acs5\"],\n          values: [\"B01001_001E\"] // population\n        },\n        (err,res) => {\n          if(err){\n            return console.error(\"Failed to load county data.\", err);\n          }\n          this.geoData.counties = res;\n\n          // Get housing data:\n          census(\n            {\n              vintage: 2018,\n              geoHierarchy: { county: '*' },\n              sourcePath: [ \"acs\", \"acs5\", \"profile\" ],\n              values: [ \"DP02_0001E\" ]\n            },\n            (err,res) => {\n              if(err){\n                return console.error(\"Failed to load county household data.\", err);\n              }\n              const self = this;\n              // Merge datasets:\n              res.forEach( d => {\n                this.geoData.counties.features.find( x => x.properties.GEOID === d.state + d.county ).properties.DP02_0001E = d.DP02_0001E;\n              });\n              console.log(\"County-Level Geo Data Loaded.\");\n            }\n          );\n        }\n      );\n      // Load State Data\n      console.log('\\t > State . . .');\n      census(\n        {\n          vintage: 2018, // most recent complete dataset\n          geoHierarchy: { state: '*' },\n          geoResolution: \"20m\",\n          sourcePath: [\"acs\", \"acs5\"],\n          values: [\"B01001_001E\"] // population\n        },\n        (err,res) => {\n          if(err){\n            return console.error(\"Failed to load county data.\", err);\n          }\n          this.geoData.states = res;\n\n          // Get housing data:\n          census(\n            {\n              vintage: 2018,\n              geoHierarchy: { state: '*' },\n              sourcePath: [ \"acs\", \"acs5\", \"profile\" ],\n              values: [ \"DP02_0001E\" ]\n            },\n            (err,res) => {\n              if(err){\n                return console.error(\"Failed to load state household data.\", err);\n              }\n              // Merge datasets:\n              res.forEach( d => {\n                this.geoData.states.features.find( x => x.properties.GEOID === d.state ).properties.DP02_0001E = d.DP02_0001E;\n              });\n              console.log(\"County-Level Geo Data Loaded.\");\n            }\n          );\n        }\n      );\n    },\n\n    // Does what it says on the tin (+ formats it and computes metaparams).\n    loadCovidData(){\n      console.log(\"\\t > County . . .\");\n      this.track.nytCounties().then(\n        data => {\n          // Extract Date Properties:\n          data.forEach( d => {\n            d.day = moment(d.date, DATE_FORMAT);\n          });\n\n          // Collect the IDs of all counties:\n          data.forEach( d => {\n            this.countyFIPS.add(d.fips);\n          });\n\n          // Fill in any missing days:\n          this.countyFIPS.forEach( fips => { // For every county:\n            // Collect the indices corresponding to each for the county:\n            let entries = data.filter( d => d.fips === fips );\n            // Get date range of data:\n            let dates = entries.map( d => d.day );\n            let firstDay = moment.min(dates);\n\n            // For every entry, check to see if an entry exists for that county\n            // for the next day (if not tomorrow), if it doesn't exist, create it.\n            let today = moment(); // Compute this once so it remains fixed during iteration\n            let day = firstDay.clone();\n            let currDayData = entries.find( d => d.day.isSame(day) );\n            currDayData.collection_date = day.format(DATE_FORMAT); // Add reference to original date of collection\n            while( day.isBefore(today, 'day') ){\n              let nextDay = day.clone().add(1,'d');\n              let nextDayData = entries.find( d => d.day.isSame(nextDay) );\n\n              if(nextDayData === undefined){\n                // Create copy of current data but with the next day's date:\n                nextDayData = { ...currDayData };\n                nextDayData.day = nextDay;\n                nextDayData.date = nextDay.format(DATE_FORMAT);\n                nextDayData.collection_date = currDayData.collection_date; // Preserve reference to original date of collection\n\n                data.push(nextDayData); // Add reference to original dataset for later use\n              } else {\n                nextDayData.collection_date = nextDayData.date; // Add reference to original date of collection for data uniformity\n              }\n\n              currDayData = nextDayData;\n              day = nextDay;\n            }\n          });\n\n          this.covidData.counties = data;\n          console.log(\"Covid Data Loaded.\");\n        },\n        err => {\n          console.error(\"Couldn't load county Covid data.\", err);\n        }\n      );\n    }\n  },\n  computed: {\n    // Compute data to be fed to the choropleth which combines geographic,\n    // census, and covid data.\n    comboData(){\n      let combo = this.covidData; // note: this will also modify covidData. That's fine. Mainly this prop is used to add reactivity.\n\n      // Pre-compute additional data:\n      // per capita, per household, per area, per density\n      for(const res in combo){\n        if(Object.prototype.hasOwnProperty.call(this.geoData[res], 'features')){\n          // Only modify data for the selected day:\n          let data = combo[res].filter( d => d.day.isSame(this.day, 'day') );\n          // For every region:\n          this.geoData[res].features.forEach( region => {\n            // Grab relevant metadata:\n            let pop = region.properties.B01001_001E;\n            let houses = region.properties.DP02_0001E;\n            let area = region.properties.ALAND / 2.59e6; // m^2 -> mi^2\n            let density = pop/area;\n            // Grab all covid entries for the region:\n            let entries = data.filter( d => d.fips === region.properties.GEOID );\n            // Add metadata to each entry:\n            entries.forEach( e => {\n              if(res === 'counties' && !e.county.includes(\"County\")){\n                e.county = e.county + \" County\"; // Clearly separate names of counties from states\n              }\n              e.pop = pop - e.deaths;\n              e.population = util.formatPopulation(e.pop);\n              e.households = util.formatPopulation(houses);\n              e.area = area;\n              e.density = util.formatPopulation(density);\n              e.cases_per_cap = util.formatPopulation(e.cases / e.pop * 1e6);\n              e.cases_per_house = util.formatPopulation(e.cases / houses * 1e6);\n              e.cases_per_area = e.cases / area;\n              e.cases_per_dens = util.formatPopulation(e.cases / density);\n              e.deaths_per_cap = util.formatPopulation(e.deaths / e.pop * 1e6);\n              e.deaths_per_house = util.formatPopulation(e.deaths / houses * 1e6);\n              e.deaths_per_area = e.deaths / area;\n              e.deaths_per_dens = util.formatPopulation(e.deaths / density);\n            });\n          });\n        }\n      }\n\n      console.log(\"Combo Data Updated.\");\n      return combo;\n    },\n    // Returns the GeoJSON being displayed on the map:\n    activeMap(){\n      return this.geoData[this.resolution];\n    },\n    // Returns the data being displayed:\n    activeData(){\n      // Find most recent data on or before selected day:\n      return this.comboData[this.resolution].filter( d => d.day.isSame(this.day, 'day') );\n    }\n  }\n}\n</script>\n\n<style scoped lang=\"scss\">\n\n</style>\n"]}]}